////////////////////////////////////////////////////////////////////////////
///
/// Copyright (C) 2011, Sony Computer Entertainment Inc. / SN Systems Limited.
///
///  @file      APIBase.h
///  @brief     Target Manager SDK for Sony PlayStation(r)3.
///  @author    support@snsys.com
///  @date      21/03/11
///	
////////////////////////////////////////////////////////////////////////////

#ifndef TMAPI_H_INC
#define TMAPI_H_INC

#define SNAPI				__declspec(dllexport)
#define SNDEPRECATED(XX)	__declspec(deprecated(XX))

#if defined __cplusplus
extern "C"
{
#endif

//////////////////////////////////////////////////////////////////////////////
/// @typedef	SNRESULT
/// @brief		All functions return a 32-bit error or return code called SNRESULT. It can be tested with
///				\link ApiBase.h::SN_SUCCEEDED SN_SUCCEEDED\endlink or \link ApiBase.h::SN_FAILED SN_FAILED\endlink.
/// @details	Possible values and general meanings (note: where functions have errors representing specific failures the value\n
///					and corresponding cause is listen in the function documentation).\n
/// SN_S_OK - The operation completed successfully.\n
/// SN_S_PENDING - The operation is pending completion.\n
/// SN_S_NO_MSG - No message in queue.\n
/// SN_S_TM_VERSION - TM version different from TMAPI version.\n
/// SN_S_CALLBACK_REPLACED - Previous callback was replaced.\n
/// SN_S_NO_ACTION - No action was necessary.\n
/// SN_S_TARGET_STILL_REGISTERED - Unregistered from custom protocol notifications, but protocol remains on target.\n
/// SN_E_NOT_IMPL - Function is not implemented.\n
/// SN_E_TM_NOT_RUNNING - Initialization of DLL failed because the TM could not be started.\n
/// SN_E_BAD_TARGET - Specified target does not exist.\n
/// SN_E_NOT_CONNECTED - Function failed because target was not connected.\n
/// SN_E_COMMS_ERR - Function failed because of a communications error with the target.\n
/// SN_E_TM_COMMS_ERR - Function failed because of a communications error with Target Manager.\n
/// SN_E_TIMEOUT - Timeout occurred during the execution of the function.\n
/// SN_E_HOST_NOT_FOUND - During a connect operation, the host could not be found.\n
/// SN_E_TARGET_IN_USE - Connect operation failed because the specified target was in use.\n
/// SN_E_LOAD_ELF_FAILED - Failed to load ELF file.\n
/// SN_E_BAD_UNIT - Specified unit is not valid.\n
/// SN_E_OUT_OF_MEM - Internal memory allocation failure.\n
/// SN_E_NOT_LISTED - Specified client is not in list for either unit update notification or TTY update notification.\n
/// SN_E_TM_VERSION - Version of Target Manager is incorrect. Contact SN Systems Support for the latest version (www.snsys.com).\n
/// SN_E_DLL_NOT_INITIALISED - The DLL has not been successfully initialised. Call \PS3Docs SNPS3InitTargetComms() \endPS3Docs \PSPDocs SNPSPInitTargetComms() \endPSPDocs.\n
/// SN_E_TARGET_RUNNING - Operation could not be completed because specified unit is running.\n
/// SN_E_BAD_MEMSPACE - Specified memory space was not valid.\n
/// SN_E_NO_TARGETS - Operation failed because there are no targets in the Target Manager.\n
/// SN_E_NO_SEL - Pick Target operation failed because no target was selected *or* the user pressed cancel.\n
/// SN_E_BAD_PARAM - An invalid parameter was passed to the function.\n
/// SN_E_BUSY - An command is still pending completion. You must wait for this command to complete before issuing another.\n
/// SN_E_DECI_ERROR - The Debug Agent returned an error.\n
/// SN_E_INSUFFICIENT_DATA - Insufficient parameters for command.\n
/// SN_E_DATA_TOO_LONG - Too much data passed to command (often due to restrictions on communications).\n
/// SN_E_DEPRECATED - Command no longer supported.\n
/// SN_E_BAD_ALIGN - Addresses or buffer sizes incorrectly aligned.\n
/// SN_E_FILE_ERROR - Error generated by a file operation.\n
/// SN_E_NOT_SUPPORTED_IN_SDK_VERSION - SDK version needs to be updated.\n
/// SN_E_LOAD_MODULE_FAILED - Failed to load module on target.\n
/// SN_E_CHECK_TARGET_CONFIGURATION - Target configuration error..\n
/// SN_E_MODULE_NOT_FOUND - Module does not exist on target.\n
/// SN_E_CONNECT_TO_GAMEPORT_FAILED - Failed to connect to game port.\n
/// SN_E_COMMAND_CANCELLED - Command cancelled by user.\n
/// SN_E_PROTOCOL_ALREADY_REGISTERED - Tried to register a second protocol on a debug station.\n
/// SN_E_CONNECTED - Tried to set connection parameters when already connected .\n
/// SN_E_ERROR - Internal error.

typedef long SNRESULT;

//////////////////////////////////////////////////////////////////////////////
///
///  @brief			Macro defined for testing the success of a function
///  @details		Returns TRUE if snr contains a success code\n
///                 Returns FALSE if snr contains a failure code.
///   

#define SN_SUCCEEDED(snr)   ((SNRESULT)(snr) >= 0)            

//////////////////////////////////////////////////////////////////////////////
///
///  @brief			Macro defined for testing the success of a function
///
///  @details	       Returns TRUE if snr contains a failure code.
///                    Returns FALSE if snr contains a success code.
///

#define SN_FAILED(snr)      ((SNRESULT)(snr) < 0)

////////////////////////////////////////////////////////////////////////////////
// ERROR CODES
////////////////////////////////////////////////////////////////////////////////

/// SN_S_OK
/// @brief The operation completed successfully.
#define SN_S_OK								(0)

/// SN_S_PENDING
/// @brief The operation is pending completion.
#define SN_S_PENDING						(1)

/// SN_S_CONNECTED
///  @deprecated	Superseded by SN_S_NO_ACTION.
#define SN_S_CONNECTED						SN_S_CONNECTED_deprecated_instead_use_SN_S_NO_ACTION

/// SN_S_NO_MSG
/// @brief No message in queue.
#define SN_S_NO_MSG							(3)

/// SN_S_TM_VERSION
/// @brief WARNING: Different version of Target Manager.
#define SN_S_TM_VERSION						(4)

/// SN_S_REPLACED
/// @brief   Previous callback or user replaced.
#define SN_S_REPLACED						(5)

/// SN_S_NO_ACTION
/// @brief   No action was necessary.
#define SN_S_NO_ACTION						(6)

/// SN_S_TARGET_STILL_REGISTERED
/// @brief   Custom protocol was unregistered, but not cleared from the target.
#define SN_S_TARGET_STILL_REGISTERED		(7)

/// SN_E_NOT_IMPL
/// @brief Function is not implemented.
#define SN_E_NOT_IMPL						(-1)

/// SN_E_TM_NOT_RUNNING
/// @brief Initialisation of DLL failed because the TM could not be started or the server shutdown while connected.
#define SN_E_TM_NOT_RUNNING					(-2)

/// SN_E_BAD_TARGET
/// @brief Specified target does not exist.
#define SN_E_BAD_TARGET						(-3)

/// SN_E_NOT_CONNECTED
/// @brief Function failed because target was not connected.
#define SN_E_NOT_CONNECTED					(-4)

/// SN_E_COMMS_ERR
/// @brief Function failed because of a communications error with the target.
#define SN_E_COMMS_ERR						(-5)

/// SN_E_TM_COMMS_ERR
/// @brief		Function failed because of a communications error with the Target 
///             Manager.
///		        When this error occurs, you should call \PS3Docs SNPS3CloseTargetComms() 
///             \endPS3Docs \PSPDocs SNPSPCloseTargetComms() \endPSPDocs and then 
///		        \PS3Docs SNPS3InitTargetComms() \endPS3Docs \PSPDocs 
///             SNPSPInitTargetComms() \endPSPDocs to reinitialize target communications
#define SN_E_TM_COMMS_ERR					(-6)

/// SN_E_TIMEOUT
/// @brief Timeout occurred during the execution of the function.
#define SN_E_TIMEOUT						(-7)

/// SN_E_HOST_NOT_FOUND
/// @brief During a connect operation, the host could not be found.
#define SN_E_HOST_NOT_FOUND					(-8)

/// SN_E_TARGET_IN_USE
/// @brief Connect operation failed because the specified target was in use.
#define SN_E_TARGET_IN_USE					(-9)

/// SN_E_LOAD_ELF_FAILED
/// @brief Failed to load ELF file.
#define SN_E_LOAD_ELF_FAILED				(-10)

/// SN_E_BAD_UNIT
/// @brief Specified unit is not valid.
#define SN_E_BAD_UNIT						(-11)

/// SN_E_OUT_OF_MEM
/// @brief Internal memory allocation failure.
#define SN_E_OUT_OF_MEM						(-12)

/// SN_E_NOT_LISTED
/// @brief		Not currently registered for notifications.
#define SN_E_NOT_LISTED						(-13)

/// SN_E_TM_VERSION
/// @brief  Version of Target Manager is incorrect. Contact SN Systems Support for the latest version (www.snsys.com).
#define SN_E_TM_VERSION						(-14)

/// SN_E_DLL_NOT_INITIALISED
/// @brief The DLL has not been successfully initialised. Call \PS3Docs SNPS3InitTargetComms() 
///             \endPS3Docs \PSPDocs SNPSPInitTargetComms() \endPSPDocs.
#define SN_E_DLL_NOT_INITIALISED			(-15)

/// SN_E_TARGET_RUNNING
/// @brief Operation could not be completed because specified unit is running.
#define SN_E_TARGET_RUNNING					(-17)

/// SN_E_BAD_MEMSPACE
/// @brief Specified memory space was not valid.
#define SN_E_BAD_MEMSPACE					(-18)

/// SN_E_NO_TARGETS
/// @brief Operation failed because there are no targets in the Target Manager.
#define SN_E_NO_TARGETS						(-19)

/// SN_E_NO_SEL
/// @brief  Pick Target operation failed because no target was selected *or* the user 
/// pressed cancel.
#define SN_E_NO_SEL							(-20)

/// SN_E_BAD_PARAM
/// @brief An invalid parameter was passed to the function.
#define SN_E_BAD_PARAM						(-21)

/// SN_E_BUSY
/// @brief   An command is still pending completion. You must wait for this command to 
/// complete before issuing another.
#define SN_E_BUSY							(-22)

/// SN_E_DECI_ERROR
/// @brief	The Debug Agent returned an error.
#define SN_E_DECI_ERROR						(-23)

/// SN_E_EXISTING_CALLBACK
///  @deprecated	Superseded by SN_S_REPLACED.
#define SN_E_EXISTING_CALLBACK				SN_E_EXISTING_CALLBACK_deprecated_instead_use_SN_S_REPLACED

/// SN_E_INSUFFICIENT_DATA
/// @brief   Insufficient parameters for command.
#define SN_E_INSUFFICIENT_DATA				(-25)

/// SN_E_DATA_TOO_LONG
/// @brief   Too much data passed to command (often due to restrictions on communications).
#define SN_E_DATA_TOO_LONG					(-26)

/// SN_E_DEPRECATED
/// @brief	 Command no longer supported.
#define SN_E_DEPRECATED						(-27)

/// SN_E_BAD_ALIGN
/// @brief	 Addresses or buffer sizes incorrectly aligned.
#define SN_E_BAD_ALIGN						(-28)

/// SN_E_FILE_ERROR
/// @brief	 Error generated by a file operation.
#define SN_E_FILE_ERROR						(-29)

/// SN_E_NOT_SUPPORTED_IN_SDK_VERSION
/// @brief   Feature is not supported by target SDK version.
#define SN_E_NOT_SUPPORTED_IN_SDK_VERSION	(-30)

/// SN_E_LOAD_MODULE_FAILED
/// @brief   Module load failed.
#define SN_E_LOAD_MODULE_FAILED				(-31)

/// SN_E_LICENSE_ERROR
///  @deprecated
#define SN_E_LICENSE_ERROR					SN_E_LICENSE_ERROR_not_used_anymore

/// SN_E_CHECK_TARGET_CONFIGURATION
/// @brief   Command failed due to target configuration error.
#define SN_E_CHECK_TARGET_CONFIGURATION		(-33)

/// SN_E_MODULE_NOT_FOUND
/// @brief   Specified module ID could not be found.
#define SN_E_MODULE_NOT_FOUND				(-34)

/// SN_E_CONNECT_TO_GAMEPORT_FAILED
/// @brief   Failed to connect to target game ethernet port.
#define SN_E_CONNECT_TO_GAMEPORT_FAILED		(-35)

/// SN_E_COMMAND_CANCELLED
/// @brief   Command has been cancelled.
#define SN_E_COMMAND_CANCELLED				(-36)

/// SN_E_PROTOCOL_ALREADY_REGISTERED
/// @brief   Tried to register a second protocol on a debug station.
#define SN_E_PROTOCOL_ALREADY_REGISTERED	(-37)

/// SN_E_CONNECTED
/// @brief Function failed because target was already connected.
#define SN_E_CONNECTED						(-38)

/// SN_E_COMMS_EVENT_MISMATCHED_ERR
/// @brief Error when parsing an event due to an incompatible client and server API version.
#define SN_E_COMMS_EVENT_MISMATCHED_ERR     (-39)

/// SN_E_TARGET_IS_POWERED_OFF
/// @brief Error when we send and event that requires the target to be on but it is off 
#define SN_E_TARGET_IS_POWERED_OFF			(-40)

/// SN_E_ERROR
/// @brief Internal error.
#define SN_E_ERROR							(0x80000000)

/// @enum		ECONNECTSTATUS
/// @brief		This enumerated type defines the different states that a connection can be in.
typedef enum ECONNECTSTATUS
{
	/// Connected State
	CS_CONNECTED, 
	/// Attempting to connect.     
	CS_CONNECTING,
	/// Not connected, available for use.
	CS_NOT_CONNECTED,
	/// In use by another user.
	CS_IN_USE,
	/// Unavailable, could be offline.
	CS_UNAVAILABLE    
} ECONNECTSTATUS;

/// @enum		EUNITSTATUS
/// @brief		This enumerated type defines the different states that a processor unit can be in.
typedef enum EUNITSTATUS
{
	/// Unknown state.
	US_UNKNOWN,             
	/// Unit is executing (PPU ONLY).
	US_RUNNING,             
	/// Unit has stopped execution (PPU ONLY).
	US_STOPPED,             
	/// A signal occurred on the unit NO LONGER USED).
	US_SIGNALLED,           
	/// Unit is in the process of resetting.
	US_RESETTING,           
	/// Unit not present (NO LONGER USED).
	US_MISSING,           
	/// Unit has completed a reset.
	US_RESET,             
	/// Unit is not connected .
	US_NOT_CONNECTED,    
	/// Unit is connected.
	US_CONNECTED, 
	/// Notification of unit status change.
	US_UNIT_STATUS_CHANGE   
} EUNITSTATUS;

/// @enum	EPOWERSTATUS
/// @brief	This enumerated type defines the different power states that a target can be in.
typedef enum EPOWERSTATUS
{
	/// Target is off.
	PS_POWER_STATE_OFF,         
	/// Target is on.
	PS_POWER_STATE_ON,          
	/// Target is suspended.
	PS_POWER_STATE_SUSPENDED,  
	/// Status is unknown.
	PS_POWER_STATE_UNKNOWN     
} EPOWERSTATUS;

/// @struct TTYSTREAM
/// @brief Structure that defines information about a TTY stream returned as part of an array from a call to SNPS3ListTTYStreams().
typedef struct TTYSTREAM
{
	/// The ID of the stream
	UINT32 nStreamIdx;
	/// A buffer to hold the textual name of the stream
	char szName[64];
} TTYSTREAM, *PTTYSTREAM;

/// @typedef	HTARGET
/// @brief		Target handle.
/// @details	This type defines the unique identifier for a particular target in the list of targets
///				handled by the Target Manager.
///				Note that if the server is shut down and restarted, target handles are invalidated.
///				Likewise if server targets are imported, specifying "delete all targets" on import (e.g. via TM GUI).
typedef int HTARGET;

/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_TARGETID       0x00000001
/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_NAME           0x00000002
/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_INFO           0x00000004
/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_HOMEDIR        0x00000008
/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_FILESERVEDIR   0x00000010
/// @brief Target info flag - used for setting which elements are to be changed.
#define SN_TI_BOOT           0x00000020

/// @brief Target details change flag - notifications about changing targets use these flags to indicate what has changed.
//  (NOT the above set of flags)
#define SN_DTLS_NAME			(1<<1)
/// @brief Target details change flag - notifications about changing targets use these flags to indicate what has changed.
#define SN_DTLS_INFO			(1<<2)
/// @brief Target details change flag - notifications about changing targets use these flags to indicate what has changed.
#define SN_DTLS_CONNECT_STAT	(1<<3)
/// @brief Target details change flag - notifications about changing targets use these flags to indicate what has changed.
#define SN_DTLS_FS_ROOT			(1<<4)
/// @brief Target details change flag - notifications about changing targets use these flags to indicate what has changed.
#define SN_DTLS_FS_HOME			(1<<5)

///  @deprecated	Use TMAPI_EnumTargetsCallback.
///  @brief			Use TMAPI_EnumTargetsCallback.
typedef int (*TMAPI_EnumTargetsCB)(HTARGET);

///  @deprecated	Use TMAPI_EnumTargetsExCallback.
///  @brief		Use TMAPI_EnumTargetsExCallback.
typedef int (*TMAPI_EnumTargetsExCB)(HTARGET, void*);

/// @typedef	TMAPI_EnumTargetsCallback
/// @brief		Target enumeration callback functions.
/// @details	The \link PS3tmapi.h::SNPS3EnumerateTargets SNPS3EnumerateTargets\endlink function takes a function pointer to a callback function
///				as an argument. During operation, \link PS3tmapi.h::SNPS3EnumerateTargets SNPS3EnumerateTargets\endlink will call this function
///				repeatedly for each target in the Target Manager, passing an hTarget handle.
///				The callback function returns 0 to continue the enumeration or non-zero to cancel it.
typedef int (__stdcall *TMAPI_EnumTargetsCallback)(HTARGET);

/// @typedef	TMAPI_EnumTargetsExCallback
/// @brief		Target enumeration callback functions.
/// @details	The \link PS3tmapi.h::SNPS3EnumerateTargetsEx SNPS3EnumerateTargetsEx\endlink function takes a pointer to a callback function as an
///				argument. During operation, \link PS3tmapi.h::SNPS3EnumerateTargetsEx SNPS3EnumerateTargetsEx\endlink will call this function
///				repeatedly for each target in the Target Manager, passing an hTarget handle.
///				The callback function returns 0 to continue the enumeration or non-zero to cancel it.
typedef int (__stdcall *TMAPI_EnumTargetsExCallback)(HTARGET, void*);

///  @deprecated	Use TMAPI_HandleEventCallback.
///  @brief	Use TMAPI_HandleEventCallback.
typedef void (*TMAPI_HandleEventCB)(HTARGET, UINT32, UINT32, SNRESULT, UINT32, BYTE*, void*);

/// @typedef	TMAPI_HandleEventCallback
/// @brief		Event callback function.
/// @details	The following functions take a pointer to a callback function as an argument:\n
///				\link PS3tmapi.h::SNPS3RegisterTTYEventHandler SNPS3RegisterTTYEventHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterTargetEventHandler SNPS3RegisterTargetEventHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterFTPEventHandler SNPS3RegisterFTPEventHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterFileTraceHandler SNPS3RegisterFileTraceHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterPadCaptureHandler SNPS3RegisterPadCaptureHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterPadPlaybackNotificationHandler SNPS3RegisterPadPlaybackNotificationHandler\endlink,\n
///				\link PS3tmapi.h::SNPS3RegisterServerEventHandler SNPS3RegisterServerEventHandler\endlink.\n
///				During operation, the
///				API will call this function for each event received from the target. It
///				is necessary to call \link PS3tmapi.h::SNPS3Kick SNPS3Kick\endlink to allow the API to enter its message loop and
///				process any pending messages.
typedef void (__stdcall *TMAPI_HandleEventCallback)(
	/// Handle to target (or NULL for system events).
	HTARGET,	
	/// Type of event (see event types below).
	UINT32,		
	/// Event parameter (event type specific).
	UINT32,	
	/// Result code (error occurred if != SN_S_OK).
	SNRESULT,	
	/// Length of data (which may include >1 event).
	UINT32,	
	/// Pointer to event data.
	BYTE*,	
	/// Optional user data.
	void*);		

/// @brief Event type.
#define SN_EVENT_TTY		(100)
/// @brief Event type.
#define SN_EVENT_TARGET		(101)
/// @brief Event type.
#define SN_EVENT_SYSTEM		(102)
/// @brief Event type.
#define SN_EVENT_FTP		(103)
/// @brief Event type.
#define SN_EVENT_PAD		(104)
/// @brief Event type.
#define SN_EVENT_FILE_TRACE	(105)
/// @brief Event type.
#define SN_EVENT_PAD_NOTIFY (106)
/// @brief Event type.
#define SN_EVENT_SERVER		(107)

/// @struct SN_EVENT_SERVER_HDR
/// @brief	Header for callback event data.
/// @details	For an \link SN_EVENT_SERVER  SN_EVENT_SERVER \endlink event the data parameter in the callback points to 
///				this structure and is followed by any other event-specific data. If the 
///				uSize member is less than the data length passed to your callback 
///				function there is more than one event available. You should loop through 
///				the data buffer, processing each event in turn.
struct SN_EVENT_SERVER_HDR {
	/// Size of server event data (including this header).
	UINT32 uSize;
	/// Target ID that event applies to, if applicable.
	UINT32 uTargetID;
	/// Server event (see \link SN_SERVER_EVENT_TARGET_ADDED SN_SERVER_EVENT_TARGET_ADDED\endlink etc).
	UINT32 uEvent;		
};

// Server events (for SN_EVENT_SERVER type).
// @name <ServerEvents>
//@{
//! Server event. See uEvent member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink. No extra data follows this event.
//  See uTargetID member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink for target added.
#define SN_SERVER_EVENT_TARGET_ADDED			(0)
//! Server event. See uEvent member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink. No extra data follows this event.
//  See uTargetID member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink for target deleted.
#define SN_SERVER_EVENT_TARGET_DELETED			(1)
//! Server event. See uEvent member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink. No extra data follows this event.
//  See uTargetID member in \link SN_EVENT_SERVER_HDR SN_EVENT_SERVER_HDR\endlink for new default target.
#define SN_SERVER_EVENT_DEFAULT_TARGET_CHANGED	(2)
//@}

/// @struct SN_EVENT_TARGET_HDR
/// @brief	Header for callback event data.
/// @details	For an SN_EVENT_TARGET event the data parameter in the callback points to 
///				this structure and is followed by any other event-specific data. If the 
///				uSize member is less than the data length passed to your callback 
///				function there is more than one event available. You should loop through 
///				the data buffer, processing each event in turn.
struct SN_EVENT_TARGET_HDR {
	/// Size of target event data (including this header).
	UINT32 uSize;
	/// Target ID that event applies to.
	UINT32 uTargetID;
	/// Target event (see SN_TGT_EVENT_UNIT_STATUS_CHANGE etc).
	UINT32 uEvent;		
};

// Target events (for \link SN_EVENT_TARGET  SN_EVENT_TARGET\endlink type).
// @name <TargetEvents>
//@{
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_UNIT_STATUS_CHANGE_DATA SN_TGT_EVENT_UNIT_STATUS_CHANGE_DATA\endlink.
#define SN_TGT_EVENT_UNIT_STATUS_CHANGE			(0)
//! Target event. See uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink. No extra data follows this event.
#define SN_TGT_EVENT_RESET_STARTED				(1)
//! Target event. See uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink. No extra data follows this event.
#define SN_TGT_EVENT_RESET_END					(2)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_DETAILS_DATA SN_TGT_EVENT_DETAILS_DATA\endlink.
#define SN_TGT_EVENT_DETAILS					(4)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_LOAD				(5)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_RUNNING				(6)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_DONE_REMOVE			(7)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_DONE_RESIDENT		(8)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_STOPPED				(9)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TGT_EVENT_MODULE_EVENT_DATA SN_TGT_EVENT_MODULE_EVENT_DATA\endlink.
#define SN_TGT_EVENT_MODULE_STOPPED_REMOVE		(10)
//! Target event. See uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink.
#define SN_TGT_POWER_STATUS_CHANGE				(11)
//! Target event. See uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink.
#define SN_TGT_TTY_STREAM_ADDED					(12)
//! Target event. See uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink.
#define SN_TGT_TTY_STREAM_DELETED				(13)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_ISOTRANSFER_STARTED			(16)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_ISOTRANSFER_FINISHED			(17)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_FORMAT_STARTED				(18)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_FORMAT_FINISHED				(19)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_MOUNT_STARTED					(20)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_MOUNT_FINISHED				(21)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_UNMOUNT_STARTED				(22)
//! Target event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SN_TM_EVENT_TGT_BD_DATA SN_TM_EVENT_TGT_BD_DATA\endlink.
#define SN_TGT_BD_UNMOUNT_FINISHED				(23)



//! Target specific event. If uEvent member in \link SN_EVENT_TARGET_HDR SN_EVENT_TARGET_HDR\endlink equals this value, header will
// be followed by \link SNPS3_DBG_EVENT_HDR SNPS3_DBG_EVENT_HDR\endlink.
#define SN_TGT_EVENT_TARGET_SPECIFIC			(0x80000000)
//@}

/// @struct SN_TGT_EVENT_UNIT_STATUS_CHANGE_DATA
/// @brief	Event-specific data for the SN_TGT_EVENT_UNIT_STATUS_CHANGE state.
struct SN_TGT_EVENT_UNIT_STATUS_CHANGE_DATA {
	/// Unit type - See \link PS3tmapi.h::ESNPS3UNIT ESNPS3UNIT\endlink for possible values
	UINT32 uUnit;
	/// Unit status - See \link ApiBase.h::EUNITSTATUS EUNITSTATUS\endlink for possible values.
	UINT32 uStatus;		
};

/// @struct	SN_TGT_EVENT_DETAILS_DATA
/// @brief	Event-specific data for the SN_TGT_EVENT_DETAILS state.
struct SN_TGT_EVENT_DETAILS_DATA {
	///	Flags representing which details have changed. See SN_DTLS_*.
	UINT32 uFlags;
};

/// @struct SN_TGT_EVENT_MODULE_EVENT_DATA
/// @brief  Event-specific data for the SN_TGT_EVENT_MODULE_* state.
struct SN_TGT_EVENT_MODULE_EVENT_DATA {
	/// Unit type - See \link PS3tmapi.h::ESNPS3UNIT ESNPS3UNIT\endlink for possible values
	UINT32 uUnit;
	/// Module ID
	UINT32 uModuleId;
};

/// @struct SN_TM_EVENT_TGT_BD_DATA
/// @brief  Event-specific data for the SN_TM_TGT_BDISOTRANSFER_FINISHED and SN_TM_TGT_BDFORMAT_FINISHED state.
struct SN_TM_EVENT_TGT_BD_DATA {
	/// Result of the BD operation
	UINT32 uResult;
	/// Source parameter of the finished operation (Path of the ISO image). UTF-8 null-terminated string.
	char szSource[512];
	/// Destination device of the finished operation (like /dev_bdemu/0). UTF-8 null-terminated string.
	char szDestination[512];
};

/// @struct		TMAPI_TCPIP_CONNECT_PROP
/// @brief		TCP/IP connection properties.
typedef struct TMAPI_TCPIP_CONNECT_PROP {
	/// IP Address
	char    szIPAddress[255];
	/// Port number
	UINT32    uPort;
} TMAPI_TCPIP_CONNECT_PROP;

/// @struct		TMAPI_TARGET_CLASS
/// @brief		Target class
typedef struct TMAPI_TARGET_CLASS {
	/// Class name
	char	szClass[256];
} TMAPI_TARGET_CLASS;

/// @struct		TMAPI_TARGET_TYPE
/// @brief		This structure contains the parameters that define a target type. It is used in the function 
///				\link PS3tmapi.h::SNPS3ListTargetTypes SNPS3ListTargetTypes\endlink to obtain information about supported target types.
typedef struct TMAPI_TARGET_TYPE {
	/// Type
	char	szType[64];
	/// Description
	char	szDescription[256];
} TMAPI_TARGET_TYPE;

/// @enum	TMAPI_FT_NOTIFY
/// @brief	File transfer notifications
enum TMAPI_FT_NOTIFY
{
	/// Notification to indicate progress
	TMAPI_FT_PROGRESS,
	/// Notification to indicate file transfer finish
	TMAPI_FT_FINISH,
	/// Notification to indicate file transfer skipped (as a file already exists with identical name, size and modification date
	TMAPI_FT_SKIPPED,
	/// Notification to indicate file transfer has been cancelled
	TMAPI_FT_CANCELLED,
	/// Notification to indicate file transfer has failed
	TMAPI_FT_ERROR,
	/// Notification to indicate file transfer pending
	TMAPI_FT_PENDING,
	/// Notification to indicate file transfer status is unknown
	TMAPI_FT_UNKNOWN,
	/// Notification to indicate the file transfer list has changed (other fields to be ignored)
	/// The list can be updated by calling SNPS3GetFileTransferList, or the notification can be safely ignored.
	TMAPI_FT_REFRESH_LIST = 0x80000000
};

/// @struct		TMAPI_FT_NOTIFICATION
/// @brief		Contains file synchronization notification data.
typedef struct TMAPI_FT_NOTIFICATION
{
	/// Notification type
	TMAPI_FT_NOTIFY m_Type;
	/// Transfer ID
	UINT32 m_TransferID;
	/// The number of bytes transferred
	UINT64 m_BytesTransferred;
} TMAPI_FT_NOTIFICATION;

/// @enum	TMAPI_LOG_CATEGORY
/// @brief	Specify what to log at server level
typedef enum TMAPI_LOG_CATEGORY
{
	/// Logging turned off
	TMAPI_LOG_CATEGORY_OFF = 0,
	/// Logging turned on
	TMAPI_LOG_CATEGORY_ALL = 0xffffffff,
} TMAPI_LOG_CATEGORY;

/// @typedef	TMAPI_SearchTargetsCallback
/// @brief		Search targets callback function.
/// @details	The following functions take a pointer to a callback function as an argument:\n
///				\link PS3tmapi.h::SNPS3SearchTargets SNPS3SearchTargets\endlink,\n
///				During operation, the API will call this function for each target. It
///				is NOT necessary to call \link PS3tmapi.h::SNPS3Kick SNPS3Kick\endlink for this function.
///				Parameters:\n
///				Name of the device (NULL if there are no more devices, and the search has finished)\n
///				Type of the device\n
///				IP address and port\n
///				User data pointer passed to the SNPS3SearchTargets function

typedef void (__stdcall *TMAPI_SearchTargetsCallback)(const char*, const char*, TMAPI_TCPIP_CONNECT_PROP*, void*);

/// @typedef	TMAPI_IdleWorker
/// @briefs		Idle worker callback function
/// @details	The following function takes a pointer to a callback function as an argument:\n
///				\link PS3tmapi.h::SNPS3RegisterIdleWorker SNPS3RegisterIdleWorker\endlink,\n
///				When this callback is registered, the API will call this function during idle time for each PS3API function call.
///				This is useful to prevent unresponsiveness in GUI applications.
///				Parameters:\n
///				User data pointer passed to the SNPS3RegisterIdleWorker function
typedef void (__stdcall *TMAPI_IdleWorker)(void*);	

#ifdef __cplusplus
}
#endif

#endif // #ifndef TMAPI_H_INC
